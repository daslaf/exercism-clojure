(group-by identity ["a" "as" "asd" "aa" "asdf" "qwer"])
(group-by identity ["aa" "as" "asd" "aa" "asdf" "qwer"])
(map inc {a 1 b 2})
(map inc {:a 1 :b 2})
(keys {:a 1 :b 2})
(let [groups (group-by identity ["aa" "as" "asd" "aa" "asdf" "qwer"])] (update-in groups (keys groups) count)
))
(let [groups (group-by identity ["aa" "as" "asd" "aa" "asdf" "qwer"])] (update-in groups (keys groups) count))
(let [groups (group-by identity ["aa" "as" "asd" "aa" "asdf" "qwer"])] groups)
(count ["aa" "aa"])
(let [groups (group-by identity ["aa" "as" "asd" "aa" "asdf" "qwer"])] (keys groups)))
(let [groups (group-by identity ["aa" "as" "asd" "aa" "asdf" "qwer"])] (keys groups))
(update-in {"aa" ["aa" "aa"], "as" ["as"]} '("aa" "as") count)
(update-in {"aa" ["aa" "aa"], "as" ["as"]} '("aa" "as") identity)
(update-in {"aa" ["aa" "aa"], "as" ["as"]} ["aa" "as"] identity)
(update-in {:aa ["aa" "aa"], :as ["as"]} [:aa :as] identity)
(update-in {:name "James" :age 26} [:age] inc)
(update-in {:name "James" :age [26]} [:age] count)
(update-in {:name ["James"] :age [26]} [:age :name] count)
(update-in {:name [123] :age [26]} [:age :name] count)
(assoc {} "foo" 1)
(assoc {"foo" 2} "foo" 1)
("foo" {"foo" 2})
({"foo" 2} "foo")
({"foo" 2} "fox")
(re-seq #"(i)\w+" "FO fo Fo")
(re-seq #"\w+" "FO fo Fo")
(re-seq #"\W+" "FO fo Fo")
(re-seq #"\w+(i)" "FO fo Fo")
(re-seq #"(i?)\w+" "FO fo Fo")
(re-seq #"i?\w+" "FO fo Fo")
(lower "FGO")
(clojure.string/lower "FGO")
(clojure.string/lowercase "FGO")
(= [1 2 3] [1 2 3])
(= (seq "listen) (seq "inlets"))
(= (seq "listen") (seq "inlets"))
(seq "listen")
(compare "listen" "istenl")
(= (sort (seq "listen")) (sort (seq "inlets")))
(sort "listen")
(sort (seq "listen"))
