(re-seq #"\w" "AEIOULNRST")
(seq "ADASDAS")
(into {} (seq {1 ["A" "E"], 2 ["D" "G"]})
)
(seq {1 ["A" "E"], 2 ["D" "G"]})
(mapcat second (seq {1 ["A" "E"], 2 ["D" "G"]}))
(mapcat (fn [[index letters]] (map (fn [letter] [letter index])  letters)) (seq {1 ["A" "E"], 2 ["D" "G"]}))
(into {} (mapcat (fn [[index letters]] (map (fn [letter] [letter index])  letters)) (seq {1 ["A" "E"], 2 ["D" "G"]})))
(clojure.string/lower-case "A")
(vec 1 2 )
(vec '(1 2))
(vector 1 2)
(flatten [1 nil [2]])
(filter #(not (nil? %)) (flatten [1 nil [2]]))
(seq 5)
(try (seq 5) (catch (seq nil)))
(try (seq 5) (catch (e Error (seq nil))))
(try (seq 5) (catch (e Error. (seq nil))))
(try (seq 5) (catch Error e (seq nil)))
(try (seq 5) (catch Exception e (seq nil)))
(try (seq 5) (catch Exception e '()))
(first [1 [2] 3])
(into () (first [1 [2] 3]))
(conj () (first [1 [2] 3]))
(conj '(4) (first [1 [2] 3]))
(cons '(4) (first [1 [2] 3]))
(cons (first [1 [2] 3]) '(4))
(conj [4] (first [1 [2] 3]))
(seq? 1)
(seq? [1])
(vec? [1])
(seqable? [1])
(seqable? (1))
(seqable? '(1))
(sequential? (1))
(sequential? '(1))
(sequential? [1])
(sequential? #{1})
(seqable? #{1})
(first [[1]])
(first 5)
(sequential? 5)
(sequential? "a")
(sequential? "ab")
(seqable? "ab")
(rest [1 2 3])
(first [])
(sequential? nil)
(head [1 2 3]) 
(first [1 2 3]) 
(next [1 2 3]) 
(rest [1 2 3]) 
(tail [1 2])]
(tail [1 2])
