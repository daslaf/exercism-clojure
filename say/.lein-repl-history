({0 "zero"} 0)
(count 1)
(clojure.string/split "12" "")
(clojure.string/split "12" #"")
(require '[stay-test :as t])
(require '[say-test :as t])
(say/tens)
say/tens
(say-test/zero-test)
(say/number 0)
(say/number 1)
(say/number 14)
(say/number 20)
(say/number 22)
(. Character getNumericValue \1)
(require '[say-test :as t])
(say/number 22)
(require '[say-test :as t] :reload)
(say/number 22)
(require 'say)
(say/number 0)
(say/number 22)
(.getNumericValue Character )
(.getNumericValue Character \d)
(.getNumericValue Character \1)
(. Character getNumericValue \1)
(Character.getNumericValue \1)
(.getNumericValue (Character \1))
(require 'say :reload)
(say/number 22)
(st/split "foo" #"")
(clojure.string/split "12" #"")
(.parseInt "1")
(. String parseInt "1")
(require 'say :reload)
(say/number 22)
000
(. Integer parseInt "000")
(clojure.string/split (str 1234) #"\d{3}")
(clojure.string/split (str 1234) #"(\d){3}")
(clojure.string/split (str 1234) #"(\d{3})")
(clojure.string/split (str 1234) #"\d{3}+")
(clojure.string/split (str 1234) #"\d{3}*")
(require 'say :reload)
(say/to-thousand-chunks 1000)
(say/to-thousand-chunks 123456)
(require 'say :reload)
(say/to-thousand-chunks 123456)
(require 'say :reload)
(say/to-thousand-chunks 123456)
(require 'say :reload)
(say/to-thousand-chunks 123456)
(require 'say :reload)
(say/to-thousand-chunks 123456)
(re-seq #"\d{3}" "1234")
(re-seq #"\d{1,3}" "1234")
(re-seq #"\d{1,3}$" "1234")
(re-seq #"\d{1,3}*?$" "1234")
(re-seq #"(\d{1,3})?$" "1234")
(partition-all 3 "1234")
(reverse (reverse (partition-all 3 "1234"))
)
(reverse (partition-all 3 (reverse "1234"))
)
(map reverse (reverse (partition-all 3 (reverse "1234"))))
(require 'say :reload)
(say/to-thousand-chunks 1234)
(require 'say :reload)
(say/to-thousand-chunks 1234)
(require 'say :reload)
(say/to-thousand-chunks 1234)
(say/to-thousand-chunks 1000)
(or false 2 5)
(.getNumericValue Character \1)
(. getNumericValue Character \1)
(. Character getNumericValue  \1)
(seq 12)
(seq "12")
(require 'say)
(say/build-number 1)
(require 'say :reload)
(say/char-to-int \1)
(say/build-number 22)
(say/build-number 1)
(say/to-thousand-chunks 12345)
(->> 12345 str)
(->> 12345 str (partition-all 3))
(->> 12345 str (into ()) (partition-all 3))
(->> 12345 str reverse (partition-all 3))
(->> 12345 str reverse (partition-all 3) (into ()))
(->> 12345 str reverse (partition-all 3) (into ()) (map #(str-to-int (apply str (into () %)))))
(->> 12345 str reverse (partition-all 3) (into ()) (map #(say/str-to-int (apply str (into () %)))))
(require 'say :reload)
(->> 12345 str reverse (partition-all 3) (into ()) (map #(say/str-to-int (apply str (into () %)))))
(subvec [2 3 4] 1 2)
(subvec [2 3 4 5] 1 2)
(subvec [2 3 4 5] 1 3)
(subvec [2 3 4 5] 1 4)
(subvec [2 3 4 5] 1 5)
(map str '(1 2) ["a" "b"]) 
(concatmap str '(1 2) ["a" "b"]) 
(mapcat str '(1 2) ["a" "b"]) 
(mapcat str '(1 2 3) ["a" "b"]) 
(interleave '(1 2 3) ["a" "b"]) 
(interleave '(1 2 3) ["a" "b" ""]) 
(require 'say :reload)
say/scale
(subvec say/scale 2)
(subvec say/scale (- 4 (count [12 345])))
(interleave [12 345] (subvec say/scale (- 4 (count [12 345]))))
(pop (interleave [12 345] (subvec say/scale (- 4 (count [12 345])))))
(butlast (interleave [12 345] (subvec say/scale (- 4 (count [12 345])))))
(require 'say :reload)
(say/with-scale '(12 234))
(require 'say :reload)
(say/number 1)
(say/number 20)
(say/number 12)
(say/number 29)
(say/number 1)
(require 'say :reload)
(say/number 1)
(say/number 12)
(say/number 22)
(say/number 99)
(say/number 100)
(say/number 10000)
(say/with-scale ()
(say/with-scale [12 345])
(say/with-scale [10 000])
(say/build-number 10000)
(say/build-number 1000)
(say/build-number 100)
(say/build-number 10)
(say/build-number 1)
(say/build-number 10)
(say/build-number 20)
(say/number 21234)
(say/buil-number 12345)
(say/build-number 12345)
(say/build-number 1234)
(say/number 1234)
(say/number 12342)
(say/with-scale (say/to-thousand-chunks 12345))
(require 'say :reload)
(say/number 12345)
(require 'say :reload)
(say/number 12345)
(require 'say :reload)
(say/number 12345)
(require 'say :reload)
(say/number 12345)
(int? 12)
(map #(when (int? %) "f") (say/number 12345))
(map #(if (int? %) (say/number %) identity) (say/number 12345))
(map #(if (int? %) (say/number %) %) (say/number 12345))
(require 'say :reload)
(say/number 12345)
(require 'say :reload)
(say/number 12345)
(say/number 22345)
(require 'say :reload)
(say/number 1)
(say/number 12)
(say/number 120)
(require 'say :reload)
(say/number 120)
(require 'say :reload)
(say/number 120)
(first "123")
(require 'say :reload)
(say/number 120)
(require 'say :reload)
(say/number 120)
(str /1 /2)
(apply str ( /1 /2))
(/1 /2)
(str \1 \2)
(require 'say :reload)
(say/number 120)
(say/number 112)
(say/number 123)
(say/number 12345)
(require 'say :reload)
(say/number 12345)
(say/number 12)
(say/number 11)
(say/number 111)
(say/number 199)
(say/number 1002)
(say/to-thousand-chunks 10000)
(say/to-thousand-chunks 1000)
(with-scale (say/to-thousand-chunks 1000))
(say/with-scale (say/to-thousand-chunks 1000))
(interleave [1] [])
(map identity [1] [])
(map identity [1 2] ["a"])
(map str [1 2] ["a"])
(require 'say :reload)
(say/with-scale [1])
(say/with-scale [1 000])
(require 'say :reload)
(say/with-scale [1])
(say/with-scale [11])
(require 'say :reload)
(say/with-scale [11])
(say/with-scale [1 234])
(say/with-scale [1 000])
(say/with-scale [1 000 000])
(assoc {:id 1 :a 2} [:id 1] 3)
(assoc {:id 1 :a 2} :id 3)
(assoc {:id 1 :a 2} :id 3 :a 3)
([1 2 3] 0)
(require 'say :reload)
(say/with-scale 1000)
(say/with-scale [1 000])
(require 'say :reload)
(say/with-scale [1 000])
(require 'say :reload)
(say/with-scale [1 000])
(say/with-scale [1 1])
(str "af" nill)
(require 'say 
:reload)
(say/over100 100)
(say/over100 101)
:reload)
(require 'say :reload)
(say/over100 101)
(say/over100 100)
(require 'say :reload)
(say/over100 100)
(say/over100 101)
(say/over100 121)
(require 'say :reload)
(say/over100 101)
(require 'say :reload)
(say/over100 101)
(say/over100 101 true)
map-indexed
(pop [1 2 3])
(str "0" "99")
(rest (str "00" "99"))
(rest (str "00" 99))
(next (str "00" 99))
(next (str "000" 99))
(take [1 2 3 4] 3)
(take 3 [1 2 3 4])
(take 3 (list (1 2 3 4))
))
(take 3 (list (1 2 3 4)))
(take 3 (list '(1 2 3 4)))
(take 3 '(1 2 3 4))
(into [] '(1 2 3 4))
(into () '(1 2 3 4))
(take-last 3 (str "00" 9))
(take-last 3 (str "00" 999))
(filter identity [1 nil 2]
)
(filter true? [1 nil 2])
(filter nil? [1 nil 2])
(apply zero? [1 2 3 0])
(clojure.string/join ", " [1 2 3])
(let [[cent & r] [1 2 3]] r)
(require 'say :reload)
(say/under1000 999)
(require 'say :reload)
(say/under1000 999)
(say/under1000 999 true)
(require 'say :reload)
(say/under1000 999 true)
(say/under1000 999)
(:hey :hey)
(is :hey :hey)
(is? :hey :hey)
(= :hey :hey)
(require 'say :reload)
(say/under1000 999 :with-and)
(say/under1000 999)
(say/to-thousand-chunks 100)
%1
(say/with-scale (say/to-thousand-chunks 100))
say/with-scale
(say/with-scale 1000)
(say/to-thousand-chunks 100)
(say/to-thousand-chunks 1000)
(say/to-thousand-chunks 10000)
(say/to-thousand-chunks 100000)
(say/to-thousand-chunks 1000000)
(interleave [1] [""])
(interleave [1 0] [:t ""])
(interleave [1 0] [:t])
(range 0 4)
(into () (range 0 4))
(map str [1 23] (into () (range 0 4)))
(range 4)
(require 'say :reload)
(say/with-scale [25 400])
(require 'say :reload)
(say/with-scale [25 400])
(require 'say :reload)
(say/with-scale [25 400])
(into () (range (count [25 499])))
(require 'say :reload)
(say/with-scale [25 400])
(require 'say :reload)
(say/number 1)
(def foo {1 ["a"] 2 (conj (foo 1) "b")}
)
(subvec [4 5 6] 1)
(require 'say :reload)
(say/with-scale [1 0])
(say/with-scale [1 1])
(say/with-scale [1])
(say/with-scale [1 0 1])
(zip [:a :b ] [1 2])
(zipmap [:a :b ] [1 2])
(require 'say :reload)
(say/with-scale [1 0 1])
(require 'say :reload)
(say/with-scale [1 0 1])
(require 'say :reload)
(say/with-scale [1 0 1])
(require 'say :reload)
(say/with-scale [1 0 1])
(defn foo [a & [b]]
(when (= b 1) (throw (IllegalArgumentException.)))
"gumball")
(foo 1)
(foo 1 2)
(foo 1 1)
(require 'say :reload)
(say/number 1)
(say/number 101)
(say/with-scale (say/to-thousand-chunks 101))
(say/under100 100 :with-and)
(say/under1000 100 :with-and)
(require 'say :reload)
(say/under1000 100 :with-and)
(say/under1000 101 :with-and)
(say/under1000 102 :with-and)
(require 'say :reload)
(say/under1000 102 :with-and)
(= 
(= '(1 2) [1 2])
(require 'say :reload)
(say/under1000 102 :with-and)
(say/under1000 100 :with-and)
(say/number 100
)
(say/number 101)
(say/number 201)
(say/number 221)
(say/number 229)
(say/number 224229)
(require 'say :reload)
(say/number 0)
(say/with-scale (say/to-thousand-chunks 0)
)
(require 'say :reload)
(say/number 0)
(require 'say :reload)
(say/number 0)
(reduce 
        (fn [acc [amount unit]]
          (cond
            (= unit "unit") (conj acc (under1000 amount))
            (zero? amount) acc
            :else (conj acc (str (under1000 amount) " " unit)))) 
        [] [[0 "unit"]])
(->> 0 say/to-thousand-chunks with-scale)
(->> 0 say/to-thousand-chunks say/with-scale)
(say/under100 0)
(say/under1000 0)
(require 'say :reload)
(say/under1000 0)
(say/under1000 1)
(say/under1000 11)
(say/under1000 21)
(say/under1000 210)
(say/under1000 10)
(say/under1000 100)
(say/under1000 200)
(say/under1000 310)
(say/under1000 301)
(require 'say :reload)
(say/number 1000)
(say/number 1)
(require 'say :reload)
(say/to-thousand-chunks 1234567)
(map + [1 2 3] [5 6])
say
(say/with-scale [1 234 123])
(interlave [1 2 3] [:a :b :c])
(interleave [1 2 3] [:a :b :c])
(interleave [1 2 3] [:a :b ])
'([1 "million"] [234 "thousand"] [123 "unit"])
(quot 12 8)
